"""Content generation API routes."""

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional
from pydantic import BaseModel

from app.database import get_db
from app import models
from app.content.generator import generate_origin_story, generate_fun_facts

router = APIRouter(prefix="/api/v1/content", tags=["content"])


class OriginStoryResponse(BaseModel):
    figure_id: int
    figure_name: str
    origin_story: str
    message: str


class FunFactResponse(BaseModel):
    figure_id: int
    figure_name: str
    facts_created: int
    message: str


class BatchContentResponse(BaseModel):
    total: int
    origin_stories_created: int
    fun_facts_created: int
    failed: int
    details: List[dict]


class UpdateOriginStoryRequest(BaseModel):
    origin_story: str


class UpdateFunFactRequest(BaseModel):
    content: str
    category: Optional[str] = None
    surprise_factor: Optional[int] = None


@router.post("/generate-origin-story/{figure_id}", response_model=OriginStoryResponse)
async def generate_origin_story_for_figure(
    figure_id: int,
    db: Session = Depends(get_db)
):
    """
    Generate an origin story for a specific figure using OpenAI GPT-4.
    """
    # Get figure
    figure = db.query(models.MythologicalFigure).filter(
        models.MythologicalFigure.id == figure_id
    ).first()
    
    if not figure:
        raise HTTPException(status_code=404, detail="Figure not found")
    
    if figure.origin_story:
        raise HTTPException(
            status_code=400,
            detail=f"Figure {figure.english_name} already has an origin story"
        )
    
    try:
        # Generate origin story
        figure_data = {
            "english_name": figure.english_name,
            "greek_name": figure.greek_name,
            "role": figure.role,
            "domain": figure.domain,
            "symbols": figure.symbols,
            "figure_type": figure.figure_type
        }
        
        origin_story = await generate_origin_story(figure_data)
        
        # Update database
        figure.origin_story = origin_story
        db.commit()
        
        return OriginStoryResponse(
            figure_id=figure.id,
            figure_name=figure.english_name,
            origin_story=origin_story,
            message="Origin story generated successfully"
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Content generation failed: {str(e)}"
        )


@router.post("/generate-fun-facts/{figure_id}", response_model=FunFactResponse)
async def generate_fun_facts_for_figure(
    figure_id: int,
    db: Session = Depends(get_db)
):
    """
    Generate fun facts for a specific figure using OpenAI GPT-4.
    """
    # Get figure
    figure = db.query(models.MythologicalFigure).filter(
        models.MythologicalFigure.id == figure_id
    ).first()
    
    if not figure:
        raise HTTPException(status_code=404, detail="Figure not found")
    
    # Check if fun facts already exist
    existing_facts = db.query(models.FunFact).filter(
        models.FunFact.figure_id == figure_id
    ).count()
    
    if existing_facts > 0:
        raise HTTPException(
            status_code=400,
            detail=f"Figure {figure.english_name} already has {existing_facts} fun facts"
        )
    
    try:
        # Generate fun facts
        figure_data = {
            "english_name": figure.english_name,
            "greek_name": figure.greek_name,
            "role": figure.role,
            "domain": figure.domain,
            "symbols": figure.symbols,
            "figure_type": figure.figure_type
        }
        
        facts = await generate_fun_facts(figure_data)
        
        # Insert into database
        facts_created = 0
        for fact in facts:
            fun_fact = models.FunFact(
                figure_id=figure_id,
                content=fact.get('content', ''),
                category=fact.get('category', 'mythological'),
                surprise_factor=fact.get('surprise_factor', 3),
                source_citation='Generated by AI based on classical sources'
            )
            db.add(fun_fact)
            facts_created += 1
        
        db.commit()
        
        return FunFactResponse(
            figure_id=figure.id,
            figure_name=figure.english_name,
            facts_created=facts_created,
            message=f"Generated {facts_created} fun facts successfully"
        )
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Content generation failed: {str(e)}"
        )


@router.post("/generate-all", response_model=BatchContentResponse)
async def generate_content_for_all_figures(
    db: Session = Depends(get_db)
):
    """
    Generate origin stories and fun facts for all figures.
    WARNING: This is expensive (uses GPT-4) and takes time.
    """
    # Get all figures
    figures = db.query(models.MythologicalFigure).all()
    
    results = {
        "total": len(figures),
        "origin_stories_created": 0,
        "fun_facts_created": 0,
        "failed": 0,
        "details": []
    }
    
    for figure in figures:
        detail = {
            "figure_id": figure.id,
            "figure_name": figure.english_name,
            "origin_story": "skipped",
            "fun_facts": "skipped"
        }
        
        try:
            figure_data = {
                "english_name": figure.english_name,
                "greek_name": figure.greek_name,
                "role": figure.role,
                "domain": figure.domain,
                "symbols": figure.symbols,
                "figure_type": figure.figure_type
            }
            
            # Generate origin story if missing
            if not figure.origin_story:
                origin_story = await generate_origin_story(figure_data)
                figure.origin_story = origin_story
                db.commit()
                results["origin_stories_created"] += 1
                detail["origin_story"] = "generated"
            else:
                detail["origin_story"] = "exists"
            
            # Generate fun facts if missing
            existing_facts = db.query(models.FunFact).filter(
                models.FunFact.figure_id == figure.id
            ).count()
            
            if existing_facts == 0:
                facts = await generate_fun_facts(figure_data)
                for fact in facts:
                    fun_fact = models.FunFact(
                        figure_id=figure.id,
                        content=fact.get('content', ''),
                        category=fact.get('category', 'mythological'),
                        surprise_factor=fact.get('surprise_factor', 3),
                        source_citation='Generated by AI based on classical sources'
                    )
                    db.add(fun_fact)
                db.commit()
                results["fun_facts_created"] += len(facts)
                detail["fun_facts"] = f"generated {len(facts)}"
            else:
                detail["fun_facts"] = f"exists ({existing_facts})"
            
            detail["status"] = "success"
            
        except Exception as e:
            results["failed"] += 1
            detail["status"] = "failed"
            detail["error"] = str(e)
            db.rollback()
        
        results["details"].append(detail)
    
    return BatchContentResponse(**results)


@router.get("/status")
async def get_content_status(db: Session = Depends(get_db)):
    """
    Get content generation status.
    """
    total = db.query(models.MythologicalFigure).count()
    with_origin_story = db.query(models.MythologicalFigure).filter(
        models.MythologicalFigure.origin_story.isnot(None)
    ).count()
    
    total_fun_facts = db.query(models.FunFact).count()
    figures_with_facts = db.query(models.FunFact.figure_id).distinct().count()
    
    return {
        "total_figures": total,
        "with_origin_stories": with_origin_story,
        "without_origin_stories": total - with_origin_story,
        "origin_story_percentage": round((with_origin_story / total * 100) if total > 0 else 0, 1),
        "total_fun_facts": total_fun_facts,
        "figures_with_fun_facts": figures_with_facts,
        "avg_facts_per_figure": round(total_fun_facts / total if total > 0 else 0, 1)
    }


@router.put("/update-origin-story/{figure_id}")
async def update_origin_story(
    figure_id: int,
    request: UpdateOriginStoryRequest,
    db: Session = Depends(get_db)
):
    """
    Update the origin story for a specific figure.
    """
    figure = db.query(models.MythologicalFigure).filter(
        models.MythologicalFigure.id == figure_id
    ).first()
    
    if not figure:
        raise HTTPException(status_code=404, detail="Figure not found")
    
    figure.origin_story = request.origin_story
    db.commit()
    
    return {
        "figure_id": figure.id,
        "figure_name": figure.english_name,
        "origin_story": figure.origin_story,
        "message": "Origin story updated successfully"
    }


@router.put("/update-fun-fact/{fact_id}")
async def update_fun_fact(
    fact_id: int,
    request: UpdateFunFactRequest,
    db: Session = Depends(get_db)
):
    """
    Update a specific fun fact.
    """
    fact = db.query(models.FunFact).filter(
        models.FunFact.id == fact_id
    ).first()
    
    if not fact:
        raise HTTPException(status_code=404, detail="Fun fact not found")
    
    fact.content = request.content
    if request.category is not None:
        fact.category = request.category
    if request.surprise_factor is not None:
        fact.surprise_factor = request.surprise_factor
    
    db.commit()
    
    return {
        "fact_id": fact.id,
        "figure_id": fact.figure_id,
        "content": fact.content,
        "category": fact.category,
        "surprise_factor": fact.surprise_factor,
        "message": "Fun fact updated successfully"
    }


@router.delete("/delete-origin-story/{figure_id}")
async def delete_origin_story(
    figure_id: int,
    db: Session = Depends(get_db)
):
    """
    Delete the origin story for a figure (allows regeneration).
    """
    figure = db.query(models.MythologicalFigure).filter(
        models.MythologicalFigure.id == figure_id
    ).first()
    
    if not figure:
        raise HTTPException(status_code=404, detail="Figure not found")
    
    figure.origin_story = None
    db.commit()
    
    return {
        "figure_id": figure.id,
        "figure_name": figure.english_name,
        "message": "Origin story deleted - ready for regeneration"
    }


@router.delete("/delete-fun-fact/{fact_id}")
async def delete_fun_fact(
    fact_id: int,
    db: Session = Depends(get_db)
):
    """
    Delete a specific fun fact.
    """
    fact = db.query(models.FunFact).filter(
        models.FunFact.id == fact_id
    ).first()
    
    if not fact:
        raise HTTPException(status_code=404, detail="Fun fact not found")
    
    figure_id = fact.figure_id
    db.delete(fact)
    db.commit()
    
    return {
        "fact_id": fact_id,
        "figure_id": figure_id,
        "message": "Fun fact deleted successfully"
    }
